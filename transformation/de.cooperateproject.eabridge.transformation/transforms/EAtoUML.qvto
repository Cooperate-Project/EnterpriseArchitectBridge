import TransformationUtils;

transformation EAtoUML(inout om: OM, in ecorePrimitives : UML, out uml:UML, out graphical : NOTATION);

modeltype OM uses eaobjectmodel('de.cooperateproject.eabridge.eaobjectmodel');
modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');
modeltype NOTATION uses notation('http://www.eclipse.org/gmf/runtime/1.0.2/notation');

main() {
	var rootPackage := om.objects()[Package]->any(p: Package | p.Parent.oclIsUndefined());
	rootPackage.map mapRootPackage();
	
	//not the only place where diagrams can be nested
	var diagrams = rootPackage.Packages.Diagrams;
	diagrams->map diagramToDiagram()
}

// mappings for transformation to uml

// Fits to the way papyrus creates new diagrams/models
mapping eaobjectmodel::Package::mapRootPackage() : uml::Model {
	name := self.Name;
	nestedPackage := self.Packages-> map mapPackage();
	
	// maybe needs some flattening?
	var associations = self.Packages.Elements.SourceRelations->select(e : Connector | e.Type = ConnectorType::Association or e.Type = ConnectorType::Aggregation);
	packagedElement += associations -> map mapConnectorToAssociation();
}

mapping eaobjectmodel::Package::mapPackage() : uml::Package
{
	name := self.Name;
	nestedPackage := self.Packages->map mapPackage();

	var classes := self.Elements->select(e:  OM::Element | e.Type=OM::ElementType::Class);
	var interfaces :=  self.Elements->select(e:  OM::Element | e.Type=OM::ElementType::Interface);
	var connectors := classes->collect(SourceRelations);
	var usages := connectors->select(e : Connector| e.Type = ConnectorType::Usage);
	var Informationflows :=  connectors->select(e : Connector| e.Type = ConnectorType::InformationFlow);
	var dependencies :=  connectors->select(e : Connector| e.Type = ConnectorType::Dependency);
	
	if (usages -> size() != 0) {
		packagedElement += usages -> map mapClassesToUsage();
	};
	if (Informationflows -> size() != 0) {
		packagedElement += Informationflows -> map mapClassesToInformationflows();
	};
	if (dependencies -> size() != 0) {
		packagedElement += dependencies -> map mapClassesToDependencies();
	};
	
	packagedElement += classes-> map mapElementToClass();	
	packagedElement += interfaces-> map mapElementToInterface();
}

mapping Connector::mapClassesToUsage():  Usage {
	name := self.Name;
	supplier += self.Source.oclAsType(Class);
	supplier += self.Dest.oclAsType(Class);
}
mapping Connector::mapClassesToDependencies():  Dependency {
	name := self.Name;
	supplier += self.Source.oclAsType(Class);
	supplier += self.Dest.oclAsType(Class);	
}
mapping Connector::mapClassesToInformationflows():  InformationFlow {
	name := self.Name;
	informationSource := self.Source.oclAsType(Class);
	informationTarget := self.Dest.oclAsType(Class);

}

abstract mapping Element::mapElementToClassifier() : uml::Classifier {
	name := self.Name;
	visibility := self.Visibility.getAttributeType();
	isAbstract := if (self.Abstract.equalsIgnoreCase("1")) then true else false endif;
	
	var generalizations = self.SourceRelations->select(e : Connector| e.Type = ConnectorType::Generalization);
	var substitutions   = self.SourceRelations->select(e : Connector| e.Type = ConnectorType::Substitution);
	
	if (generalizations -> size() != 0) {
		generalization := generalizations -> map mapConnectoToGeneralization();
	};
	if (substitution -> size() != 0) {
		substitution := substitutions -> map mapConnectoToSubstitution();
	};
	
}

mapping Element::mapElementToClass() : uml::Class
inherits Element::mapElementToClassifier 
{	
	ownedAttribute += self.Attributes-> map transformAttribute();
	ownedOperation += self.Methods-> map transformOperations();
	
	var realizations = self.SourceRelations->select(e : Connector | e.Type = ConnectorType::Realisation);	
	var associations = self.SourceRelations->select(e : Connector | e.Type = ConnectorType::Association or e.Type = ConnectorType::Aggregation);
	
	if (realizations -> size() != 0) {
		interfaceRealization := realizations -> map mapConnectoToRealization();
	};
}

mapping Element::mapElementToInterface() :  uml::Interface
inherits Element::mapElementToClassifier
{
	ownedAttribute := self.Attributes-> map transformAttribute();
	ownedOperation := self.Methods-> map transformOperations();
	isAbstract := false;
	
	var realizations = self.SourceRelations->select(e : Connector | e.Type = ConnectorType::Realisation);	
	var associations = self.SourceRelations->select(e : Connector | e.Type = ConnectorType::Association or e.Type = ConnectorType::Aggregation);	
}

mapping Attribute::transformAttribute() :  uml::Property
{
	name := self.Name;
	visibility := self.Scope.getAttributeType();
	if (self.AttributeType.classifier=null) 
		then type := self.AttributeType.getPrimitiveType().transformPrimitive() 
		else (type := self.AttributeType.classifier.late resolveone(uml::Classifier)) 
	endif;
	if (type=null) then (type := self.AttributeType.classifier.late resolveone(uml::Classifier)) endif;
}

mapping Connector::mapConnectoToGeneralization() :  Generalization
{
	general := self.Dest.late resolveone(uml::Classifier);
}
mapping Connector::mapConnectoToSubstitution() :  uml::Substitution
{
	supplier := self.Dest.late resolveone(uml::Classifier);
}
mapping Connector::mapConnectoToRealization() :  InterfaceRealization
{
	supplier := self.Dest.late resolveone(uml::Classifier);
	contract := self.Dest.late resolveone(uml::Interface);
}

mapping Connector::mapConnectorToAssociation() : uml::Association
{	
	name := self.Name;
	memberEnd += self.map mapSourceToProperty();
	memberEnd += self.map mapDestToProperty();
	// does not work for ownedAttributes of Interfaces
	if (self.SourceIsNavigable) 
		then (self.Dest.resolveone(uml::StructuredClassifier).ownedAttribute += self.resolveoneIn(Connector::mapSourceToProperty))
		else (ownedEnd += self.resolveoneIn(Connector::mapSourceToProperty))
	endif;
	if (self.DestIsNavigable)
		then (self.Source.resolveone(uml::StructuredClassifier).ownedAttribute += self.resolveoneIn(Connector::mapDestToProperty))
		else (ownedEnd += self.resolveoneIn(Connector::mapDestToProperty))
	endif;
}

//for more properties the semikolon seperated lists SourceStyle and DestSystle need to be parsed
mapping Connector::mapSourceToProperty() : uml::Property
{
	//EA uses the aggregation property the other way round
	aggregation := self.DestIsAggregate.transformAssociationType();
	name := self.getSourceAlias();
	
	type := self.Source.late resolveone(uml::Classifier);
	if (self.getSourceLower() != 1) then lower := self.getSourceLower() endif;
	if (self.getSourceUpper() != 1) then upper := self.getSourceUpper() endif;
}

mapping Connector::mapDestToProperty() : uml::Property
{
	//EA uses the aggregation property the other way round
	aggregation := self.SourceIsAggregate.transformAssociationType();
	name := self.getDestAlias();
	
	type := self.Dest.late resolveone(uml::Classifier);
	if (self.getDestLower() != 1) then lower := self.getDestLower() endif;
	if (self.getDestUpper() != 1) then upper := self.getDestUpper() endif;
}

query IsAggregate::transformAssociationType() : uml::AggregationKind
{
	return switch {
		case (self = IsAggregate::False) AggregationKind::none;
		case (self = IsAggregate::Aggregation) AggregationKind::shared;
		case (self = IsAggregate::Composition) AggregationKind::composite;
		else assert error (false) with log("Illegal enum value");
	};
}

mapping String::StringToCardinality() :  LiteralInteger
{
	value := self.toInteger();
}

mapping Method::transformOperations() :  Operation
{
	name := self.Name;
	ownedParameter := self.Parameters -> map transformParameters();
	ownedParameter += self.ReturnType.map TypeReferenceToParamter();
	visibility := self.Visibility.getAttributeType();
	
}
mapping Methodparameter::transformParameters() :  uml::Parameter
{
	name := self.Name;
	if (self.ParameterType.classifier=null) 
		then type := self.ParameterType.getPrimitiveType().transformPrimitive() 
		else (type := self.ParameterType.classifier.late resolveone(uml::Classifier)) 
	endif;
	direction := ParameterDirectionKind::_in;	
	
}

mapping in TypeReference::TypeReferenceToParamter() : uml::Parameter 
{
	direction := ParameterDirectionKind::_return;
	if (self.classifier=null) 
		then type := self.getPrimitiveType().transformPrimitive() 
		else (type := self.classifier.late resolveone(uml::Classifier)) 
	endif;

}

// queries for transformation to uml

query PrimitiveType::transformPrimitive() : uml::PrimitiveType
{
	var type = switch {
		case (self = PrimitiveType::Int) getPrimitive('EInt');
		case (self = PrimitiveType::Boolean) getPrimitive('EBoolean');
		case (self = PrimitiveType::Byte) getPrimitive('EByte');
		case (self = PrimitiveType::Char) getPrimitive('EChar');
		case (self = PrimitiveType::Double) getPrimitive('EDouble');
		case (self = PrimitiveType::Float) getPrimitive('EFloat');
		case (self = PrimitiveType::Long) getPrimitive('ELong');
		case (self = PrimitiveType::Short) getPrimitive('EShort');
		case (self = PrimitiveType::String) getPrimitive('EString');
	};
	assert warning (type <> null) with log ('Could not interpret primitive datatype \"' + self.toString() + '\".');
	return type;
}

query getPrimitive(typeName : String) : uml::PrimitiveType
{
	var model := ecorePrimitives.rootObjects()[uml::Model]->any(true);
	var primitives := model.ownedElement->selectByType(uml::PrimitiveType);
	return primitives->any(typeName = name);
}

query Scope::getAttributeType() : VisibilityKind
{
 return switch {
		case (self = Scope::Private)  VisibilityKind::private; 
		case (self = Scope::Public) VisibilityKind::public;
		case (self = Scope::Package) VisibilityKind::package;
		case (self = Scope::Protected) VisibilityKind::protected;
		else assert error (false) with log("Illegal enum value");
	};
} 


query ScopeObject::getAttributeType() : VisibilityKind
{
	return if self = null then null else self.oclAsType(Scope).getAttributeType() endif;
}

// transformation to notation
// getNestedName

mapping eaobjectmodel::Diagram::diagramToDiagram() : notation::Diagram {
	type := "PapyrusUMLClassDiagram";
	name := self.Name;
	measurementUnit := notation::MeasurementUnit::Pixel;
	
	var eaRootElement := om.objects()[Package]->any(p: Package | p.Parent.oclIsUndefined());
	var rootPackage := eaRootElement.resolveone(uml::Model).oclAsType(uml::Package);
	element := rootPackage.toEObject();
	
	children += self.DiagramObjects-> map diagramObjectToShape();
}

//DiagramObjects
mapping DiagramObject::diagramObjectToShape() : Shape
merges DiagramObject::classToShape {
	element := self.Element.resolveone(uml::Classifier).toEObject();
	
	children += self.map diagramObjectToNameDecorationNode();
	children += self.map diagramObjectToFloatingLabelDecorationNode();
	
	children += self.map diagramObjectToAttributesCompartment();
	children += self.map diagramObjectToOperationsCompartment();
	children += self.map diagramObjectToSignalsCompartment();
	
	layoutConstraint := self.map diagramObjectToLayoutConstraint();
}

mapping DiagramObject::classToShape() : Shape 
when {self.Element.Type = ElementType::Class} {
	type := PAPYRUS_NOTATION_SHAPE_CLASS_REGULAR;
}


//NameDecorationNode
mapping DiagramObject::diagramObjectToNameDecorationNode() : DecorationNode
merges DiagramObject::classToNameDecorationNode {
	
}

mapping DiagramObject::classToNameDecorationNode() : DecorationNode 
when {self.Element.Type = ElementType::Class} {
	type := PAPYRUS_NOTATION_NODE_CLASS_NAME_REGULAR;
}

//LayoutConstraint
mapping DiagramObject::diagramObjectToLayoutConstraint() : Bounds {
	width := self.Right - self.Left;
	height := (self.Bottom - self.Top) * -1;
	x := (width/2).floor();
	y := (height/2).floor();
}

//FloatingLabelDecorationNode
mapping DiagramObject::diagramObjectToFloatingLabelDecorationNode() : DecorationNode
merges DiagramObject::classToFloatingLabelDecorationNode {
	layoutConstraint := result.toEObject().map locationConstraint();
}

mapping DiagramObject::classToFloatingLabelDecorationNode() : DecorationNode 
when {self.Element.Type = ElementType::Class} {
	type := PAPYRUS_NOTATION_NODE_CLASS_FLOATINGLABEL_REGULAR;
}

//AttributeCompartment
mapping DiagramObject::diagramObjectToAttributesCompartment() : BasicCompartment
merges DiagramObject::classToAttributesCompartment {
	children += self.Element.Attributes-> map attributeToShape();
	styles += result.toEObject().map titleStyle();
	styles += result.toEObject().map sortingStyle();
	styles += result.toEObject().map filteringStyle();
	layoutConstraint := result.toEObject().map notationBounds();
}

mapping DiagramObject::classToAttributesCompartment() : BasicCompartment
when {self.Element.Type = ElementType::Class} {
	type := PAPYRUS_NOTATION_COMPARTMENT_CLASS_PROPERTIES_REGULAR;
}

//Attribute
mapping Attribute::attributeToShape() : Shape
merges Attribute::classAttributeToShape {
	element := self.resolveone(uml::Property).toEObject();
	layoutConstraint := result.toEObject().map locationConstraint();
}

mapping Attribute::classAttributeToShape() : Shape
when {self.Parent.Type = ElementType::Class} {	
	type := PAPYRUS_NOTATION_SHAPE_CLASS_ATTRIBUTE;
}

//MethodCompartment
mapping DiagramObject::diagramObjectToOperationsCompartment() : BasicCompartment
merges DiagramObject::classToOperationsCompartment {
	children += self.Element.Methods-> methodToShape();
	styles += result.toEObject().map titleStyle();
	styles += result.toEObject().map sortingStyle();
	styles += result.toEObject().map filteringStyle();
	layoutConstraint := result.toEObject().map notationBounds();
}

mapping DiagramObject::classToOperationsCompartment() : BasicCompartment
when {self.Element.Type = ElementType::Class} {
	type := PAPYRUS_NOTATION_COMPARTMENT_CLASS_OPERATIONS_REGULAR;
}

//Method
mapping Method::methodToShape() : Shape
merges Method::classMethodToShape {
	element := self.resolveone(uml::Operation).toEObject();
	layoutConstraint := result.toEObject().map locationConstraint();
}

mapping Method::classMethodToShape() : Shape
when {self.Parent.Type = ElementType::Class} {	
	type := PAPYRUS_NOTATION_SHAPE_CLASS_OPERATION;
}

//SignalCompartment
mapping DiagramObject::diagramObjectToSignalsCompartment() : notation::BasicCompartment
merges DiagramObject::classToSignalsCompartment
{
	styles += result.toEObject().map titleStyle();
	styles += result.toEObject().map sortingStyle();
	styles += result.toEObject().map filteringStyle();
	layoutConstraint := result.toEObject().map notationBounds();
}

mapping DiagramObject::classToSignalsCompartment() : notation::BasicCompartment
when {self.Element.Type = ElementType::Class}
{
	type := PAPYRUS_NOTATION_COMPARTMENT_CLASS_NESTED_REGULAR;
}
