transformation UMLtoEA(in uml: UML,in ecorePrimitives : UML, out om: OM);
modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');
modeltype OM uses eaobjectmodel('de.cooperateproject.eabridge.eaobjectmodel');

main() {

	var rootModels := uml.rootObjects()[Model];
	assert fatal (rootModels->size() = 1);

	log("Found Root Models", rootModels);
	
	rootModels -> map mapRootModel();

}

mapping uml::Model::mapRootModel() : eaobjectmodel::Package {
	
	log("Mapping root model", self);
	
	Name := self.name;
	Packages := self.nestedPackage-> map mapPackages();
	
	// FIXME: Root Model package ID always 1?
	PackageID := 1;
	
	// Create package element
	Elements := self.nestedPackage-> map mapPackageToElement();
	
	// TODO: Map Associations
	
}

mapping uml::Package::mapPackages() : eaobjectmodel::Package {
	
	log("Mapping package", self);
	
	// TODO: Package ID?
	
	Name := self.name;	
	Packages := self.nestedPackage-> map mapPackages();
	
	// Create package element
	Elements := self.nestedPackage-> map mapPackageToElement();
	
	// Map Package content
	var classes := self.packagedElement->selectByType(UML::Class);
	var interfaces := self.packagedElement->selectByType(UML::Interface);
	
	Elements += classes -> map mapClassToElement();
	// TODO: Elements += interfaces -> map mapInterfaceToElement();
	
	// TODO: What else?
}

mapping uml::Package::mapPackageToElement() : eaobjectmodel::Element {
	
	Name := self.name;
	
}

mapping uml::Class::mapClassToElement(): eaobjectmodel::Element {
	
	log("Mapping class", self);
	
	Name := self.name;
	Abstract := if (self.isAbstract) then "1" else "0" endif;
	
	// FIXME: Conversion of Scope to ScopeObject fails (but ScopeObject -> Scope works)
	Visibility := self.visibility.transformVisibility().oclAsType(ScopeObject);

	
	log("Input element visibility:", self.visibility);
	log("Output element visibility:", result.Visibility);
	
	// TODO: Generalisation, (Realization), Association
	
	Attributes := self.ownedAttribute -> map mapPropertyToAttribute();
	Methods := self.ownedOperation -> map mapOperationToMethod();
	
}

query VisibilityKind::transformVisibility() : Scope {
	
	// Incremental?
	var visibilityScope = switch {
		case (self = VisibilityKind::public) Scope::Public;
		case (self = VisibilityKind::private) Scope::Private;
		case (self = VisibilityKind::protected) Scope::Protected;
		case (self = VisibilityKind::package) Scope::Package;
		else assert error (false) with log("Illegal enum value");
	};
	
	return visibilityScope;
	
}

mapping uml::Property::mapPropertyToAttribute(): Attribute {
	
	log("Mapping attribute", self);
	
	Name := self.name;

	result.Scope := self.visibility.transformVisibility();
	AttributeType := self.type.map mapTypeToTypeReference();
	
}

mapping uml::Type::mapTypeToTypeReference(): TypeReference
disjuncts 
uml::PrimitiveType::primitiveTypeToTypeReference, 
uml::Class::classToTypeReference 
{}

mapping uml::PrimitiveType::primitiveTypeToTypeReference() : TypeReference {
	
	log("Mapping primitive type", self);
	
	// FIXME: Sometimes missing type reference?!
	// Solution: this should be a query, no mapping. Replace disjuncts
	var type = self.transformPrimitive();
	result.typeName := 	type.toString();

}

query uml::PrimitiveType::transformPrimitive() : OM::PrimitiveType {
	var type = switch {
		case (self.name = "EInt") OM::PrimitiveType::Int;
		case (self.name = "EBoolean") OM::PrimitiveType::Boolean;
		case (self.name = "EByte") OM::PrimitiveType::Byte;
		case (self.name = "EChar") OM::PrimitiveType::Char;
		case (self.name = "EDouble") OM::PrimitiveType::Double;
		case (self.name = "ELong") OM::PrimitiveType::Long;
		case (self.name = "EFloat") OM::PrimitiveType::Float;
		case (self.name = "EShort") OM::PrimitiveType::Short;
		case (self.name = "EString") OM::PrimitiveType::String;
	};
	
	assert warning (type <> null) with log ("Could not interpret primitive datatype \"" + self.name + "\".");
	return type;
}

mapping uml::Class::classToTypeReference() : TypeReference {
	
	log("Mapping class", self);
	
	// TODO: Not working correctly
	// classifier = self.name.late resolveone(uml::Element);
	
}

mapping Operation::mapOperationToMethod() : Method {
	
	log("Mapping operation", self);
	
	Name := self.name;
	Visibility := self.visibility.transformVisibility();
	
	self.ownedParameter-> forEach(param) {
		if(param.direction = ParameterDirectionKind::_return) then 
		result.ReturnType := param.type.map mapTypeToTypeReference() endif;
		
		if(param.direction <> ParameterDirectionKind::_return) then
		result.Parameters += param.map transformParameters() endif;
	};
	
}

mapping uml::Parameter::transformParameters() : Methodparameter {
	
	log("Mapping parameter", self);
	
	Name := self.name;
	Kind := self.direction.transformParameterDirection();
	ParameterType := self.type.map mapTypeToTypeReference();
}

query uml::ParameterDirectionKind::transformParameterDirection() : ParameterDirection {
	return switch {
		case (self = ParameterDirectionKind::_in) ParameterDirection::_in;
		case (self = ParameterDirectionKind::_out) ParameterDirection::_out;
		case (self = ParameterDirectionKind::_inout) ParameterDirection::_inout;
		case (self = ParameterDirectionKind::_return) ParameterDirection::_return;
	};
}
