transformation UMLtoEA(in uml: UML, in ecorePrimitives : UML, in notation : NOTATION,  out om : OM);
modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');
modeltype NOTATION uses notation('http://www.eclipse.org/gmf/runtime/1.0.2/notation');
modeltype OM uses eaobjectmodel('de.cooperateproject.eabridge.eaobjectmodel');

main() {
	var rootModels := uml.rootObjects()[Model];
	assert fatal (rootModels->size() = 1);

	log("Found Root Models", rootModels);
	
	object eaobjectmodel::Package {
		Name := "Root";
		Packages += rootModels.map mapPackage();
		Elements += rootModels.map mapPackageToElement();
	};
	
	var diagrams := notation.objectsOfType(Diagram);
	diagrams -> map mapDiagram();
}

mapping uml::Package::mapPackage() : eaobjectmodel::Package {
	log("Mapping package", self);
	
	Name := self.name;	
	Packages := self.nestedPackage-> map mapPackage();
	
	// Create package element
	Elements := self.nestedPackage-> map mapPackageToElement();
	
	// Map Package content
	var classes := self.packagedElement->selectByType(UML::Class);
	var interfaces := self.packagedElement->selectByType(UML::Interface);
	var associations := self.packagedElement->selectByType(UML::Association);
	var comments := self.ownedComment;

	
	Elements += classes -> map mapClassToElement();
	Elements += interfaces -> map mapInterfaceToElement();
				associations -> map mapAssociationToConnector();
	Elements += comments -> map mapCommentToElement();
	
}

mapping uml::Package::mapPackageToElement() : eaobjectmodel::Element {
	Name := self.name;
	Abstract := "0";
	result.Type := ElementType::Package;
	PDATA1 := self.late resolveone(eaobjectmodel::Package);
	
	SourceRelations += self.packageImport -> map mapPackageImportToConnector();
}

abstract mapping uml::Classifier::mapClassifierToElement(): eaobjectmodel::Element {
	log("Mapping Classifier", self);
	PDATA1 := null;
	
	Name := self.name;
	Abstract := if (self.isAbstract) then "1" else "0" endif;
	
	// FIXME: Conversion of Scope to ScopeObject fails (but ScopeObject -> Scope works)
	Visibility := self.visibility.transformVisibility().oclAsType(ScopeObject);
	
	log("Input element visibility:", self.visibility);
	log("Output element visibility:", result.Visibility);
	
	SourceRelations += self.generalization.map mapGeneralizationToConnector();
	SourceRelations += self.substitution.map mapSubstitutionToConnector();
}

mapping uml::Class::mapClassToElement(): eaobjectmodel::Element
inherits uml::Classifier::mapClassifierToElement {
	log("Mapping class", self);
	
	Attributes := self.ownedAttribute-> select(p : Property | p.association.oclIsUndefined()).map mapPropertyToAttribute();
	Methods := self.ownedOperation -> map mapOperationToMethod();
	
	result.Type := eaobjectmodel::ElementType::Class;
	
	SourceRelations += self.interfaceRealization.map mapRealizationToConnector();
}

mapping uml::Interface::mapInterfaceToElement() : eaobjectmodel::Element
inherits uml::Classifier::mapClassifierToElement {
	log("Mapping interface", self);
	
	Attributes := self.ownedAttribute -> map mapPropertyToAttribute();
	Methods := self.ownedOperation -> map mapOperationToMethod();
	
	result.Type := eaobjectmodel::ElementType::Interface;
	
	result.Abstract := "1";
}

mapping uml::Comment::mapCommentToElement() : eaobjectmodel::Element {
	log("Mapping comment", self);
	PDATA1 := null;
	
	Notes := self.body;
	SourceRelations := self.annotatedElement.map mapElementToNoteLink();
	
	result.Type := eaobjectmodel::ElementType::Note;
	
	result.Abstract := "0";
}

mapping uml::Association::mapAssociationToConnector() : eaobjectmodel::Connector {
	log("Mapping association", self);
		
	Name := self.name;
	
	var sourceProperty := self.memberEnd->at(1);
	var destProperty := self.memberEnd->at(2);
	Source := sourceProperty.type.resolveone(OM::Element);
	Dest := destProperty.type.resolveone(OM::Element);
	
	// If the property was not assigned to the association it is possible to navigate to this memberEnd
	SourceIsNavigable := sourceProperty.owningAssociation = null;
	DestIsNavigable := destProperty.owningAssociation = null;
	
	Direction := result.transformDirectionType();
	
	SourceIsAggregate := self.memberEnd->at(2).transformAssociationType();
	DestIsAggregate := self.memberEnd->at(1).transformAssociationType();
	
	SourceRole := sourceProperty.name;
	DestRole := destProperty.name;
	
	if (sourceProperty.getLower() = sourceProperty.getUpper())
		then SourceCard := sourceProperty.getLower().toString()
		else SourceCard := sourceProperty.getLower().toString() + ".." + sourceProperty.getUpper().toString()
	endif;
	
	if (destProperty.getLower() = destProperty.getUpper())
		then DestCard := destProperty.getLower().toString()
		else DestCard := destProperty.getLower().toString() + ".." + destProperty.getUpper().toString()
	endif;
	
	result.Type := ConnectorType::Association;
}

abstract mapping uml::DirectedRelationship::mapDirectedRelationShip() : OM::Connector {
	Direction := DirectionType::SourceDestination;
	DestIsNavigable := true;
}

mapping uml::Generalization::mapGeneralizationToConnector() : eaobjectmodel::Connector
inherits uml::DirectedRelationship::mapDirectedRelationShip {
	log("Mapping generalization", self);
	
	Dest := self.general.late resolveone(OM::Element);
	result.Type := ConnectorType::Generalization;
}

mapping uml::Substitution::mapSubstitutionToConnector() : eaobjectmodel::Connector
inherits uml::DirectedRelationship::mapDirectedRelationShip {
	log("Mapping substitution", self);
	
	Dest := self.supplier.late resolveone(OM::Element);
	result.Type := ConnectorType::Substitution;
}

mapping uml::InterfaceRealization::mapRealizationToConnector() : eaobjectmodel::Connector
inherits uml::DirectedRelationship::mapDirectedRelationShip {
	log("Mapping realization", self);
	
	Dest := self.supplier.late resolveone(OM::Element);
	result.Type := ConnectorType::Realisation;
}

mapping uml::PackageImport::mapPackageImportToConnector() : eaobjectmodel::Connector
inherits uml::DirectedRelationship::mapDirectedRelationShip {
	log("Mapping packageImport",self);
	
	Dest := self.importedPackage.resolveoneIn(uml::Package::mapPackageToElement, eaobjectmodel::Element);
	result.Type := ConnectorType::Package;
	Btm_Mid_Label := "<<import>>";
	result.Stereotype := "import";
}

mapping uml::Element::mapElementToNoteLink() : eaobjectmodel::Connector {
	log("Mapping noteLink", self);
	
	Dest := self.resolveone(eaobjectmodel::Element);
	
	Direction := DirectionType::SourceDestination;
	result.Type := ConnectorType::NoteLink;
}

mapping uml::Property::mapPropertyToAttribute(): Attribute {
	log("Mapping attribute", self);
	
	Name := self.name;

	result.Scope := self.visibility.transformVisibility();
	AttributeType := self.type.transformType();
}

mapping uml::Operation::mapOperationToMethod() : Method {
	log("Mapping operation", self);
	
	Name := self.name;
	Visibility := self.visibility.transformVisibility();
	
	self.ownedParameter-> forEach(param) {
		if (param.direction = ParameterDirectionKind::_return) then 
		result.ReturnType := param.type.transformType() endif;
		
		if (param.direction <> ParameterDirectionKind::_return) then
		result.Parameters += param.map mapParameter() endif;
	};
}

mapping uml::Parameter::mapParameter() : Methodparameter {
	log("Mapping parameter", self);
	
	Name := self.name;
	Kind := self.direction.transformParameterDirection();
	ParameterType := self.type.transformType();
}

query uml::Property::transformAssociationType() : IsAggregate {
	return switch {
		case (self.aggregation = AggregationKind::none) IsAggregate::False;
		case (self.aggregation = AggregationKind::shared) IsAggregate::Aggregation;
		case (self.aggregation = AggregationKind::composite) IsAggregate::Composition;
		else assert error (false) with log("Illegal enum value");
	};
}

query uml::ParameterDirectionKind::transformParameterDirection() : ParameterDirection {
	return switch {
		case (self = ParameterDirectionKind::_in) ParameterDirection::_in;
		case (self = ParameterDirectionKind::_out) ParameterDirection::_out;
		case (self = ParameterDirectionKind::_inout) ParameterDirection::_inout;
		case (self = ParameterDirectionKind::_return) ParameterDirection::_return;
	};
}

query VisibilityKind::transformVisibility() : Scope {
	return switch {
		case (self = VisibilityKind::public) Scope::Public;
		case (self = VisibilityKind::private) Scope::Private;
		case (self = VisibilityKind::protected) Scope::Protected;
		case (self = VisibilityKind::package) Scope::Package;
		else assert error (false) with log("Illegal enum value");
	};
}

query uml::PrimitiveType::transformPrimitive() : OM::PrimitiveType {
	return switch {
		case (self.name = "EInt") OM::PrimitiveType::Int;
		case (self.name = "EBoolean") OM::PrimitiveType::Boolean;
		case (self.name = "EByte") OM::PrimitiveType::Byte;
		case (self.name = "EChar") OM::PrimitiveType::Char;
		case (self.name = "EDouble") OM::PrimitiveType::Double;
		case (self.name = "ELong") OM::PrimitiveType::Long;
		case (self.name = "EFloat") OM::PrimitiveType::Float;
		case (self.name = "EShort") OM::PrimitiveType::Short;
		case (self.name = "EString") OM::PrimitiveType::String;
		else assert error (false) with log("Could not interpret primitive datatype \"" + self.name + "\".");
	};
}

query OM::Connector::transformDirectionType() : OM::DirectionType {
	return switch {
		case (self.SourceIsNavigable and self.DestIsNavigable) DirectionType::BiDirectional;
		case (self.SourceIsNavigable) DirectionType::DestinationSource;
		case (self.DestIsNavigable) DirectionType::SourceDestination;
		else DirectionType::Unspecified;
	};
 }

query uml::Type::transformType(): TypeReference {

	//FIXME: Good idea? (Alternative: Code dublication)
	var reference = new TypeReference();

	if (self.oclIsTypeOf(uml::PrimitiveType)) then {
		log("Transforming primitive type", self);
		reference.typeName := self.oclAsType(uml::PrimitiveType).transformPrimitive().toString();
	} else {
		log("Late resolving class type", self);
		reference.classifier := self.oclAsType(uml::Class).late resolveone(OM::Element);
		// FIXME: After resolving the classifier, set the typeName (Maybe not needed)
		//reference.typeName := self.oclAsType(uml::Class).late resolveone(OM::Element)->any(t | t = self.toString());
	} endif;
	
	return reference;
}

//Graphical

mapping notation::Diagram::mapDiagram() : eaobjectmodel::Diagram {
	log("Mapping diagram", self);
	Name := self.name;
	
	result.Type := "Logical";
	Orientation := "P";
	
	result.Package := self.element.oclAsType(uml::Package).resolveone(eaobjectmodel::Package);
	self.children->selectByType(notation::Shape)->map mapShape(0, 0);
	
}

mapping notation::Shape::mapShape(packageLeft : Integer, packageTop : Integer) : eaobjectmodel::DiagramObject {
	log("Mapping diagramobject", self);

	result.Element := self.element.resolveone(eaobjectmodel::Element);
	result.Diagram := self.diagram.resolveone(eaobjectmodel::Diagram);
	
	Left := self.getBounds().x + packageLeft;
	Top := packageTop - self.getBounds().y;
	Right := self.getBounds().width + result.Left;
	Bottom := result.Top - self.getBounds().height;
	
//	self.children->subobjectsOfType(notation::Shape)->flatten()-> forEach(shape) {
//		log("DEBUG", shape.oclAsType(notation::Shape));
//	};
	
	self.children->subobjectsOfType(notation::Shape)->flatten()->map mapShape(result.Left, result.Top);
}

mapping notation::Connector::mapConnector() : eaobjectmodel::DiagramLink {
	log("Mapping diagramlink", self);
	
	result.Connector := self.element.oclAsType(uml::Relationship).resolveone(eaobjectmodel::Connector);
	result.Diagram := self.diagram.resolveone(eaobjectmodel::Diagram);
}

query notation::Shape::getBounds() : notation::Bounds {
	return self.layoutConstraint.oclAsType(notation::Bounds);
}
