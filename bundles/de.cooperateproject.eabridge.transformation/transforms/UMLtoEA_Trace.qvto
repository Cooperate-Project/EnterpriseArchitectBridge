import TraceUtils;

transformation UMLtoEA_Trace(in umlTrace : TRACE, out eaTrace : TRACE, in eaModel : OM, in eaToUMLTransformation : QVTO);

modeltype QVTO uses qvtoperational('http://www.eclipse.org/QVT/1.0.0/Operational');
modeltype TRACE uses trace('http:///www.eclipse.org/m2m/qvt/operational/trace.ecore');
modeltype UML uses uml('http://www.eclipse.org/uml2/5.0.0/UML');
modeltype OM uses eaobjectmodel('de.cooperateproject.eabridge.eaobjectmodel');
modeltype NOTATION uses notation('http://www.eclipse.org/gmf/runtime/1.0.2/notation');
modeltype ECORE uses ecore('http://www.eclipse.org/emf/2002/Ecore');

main() {
	var traces := umlTrace.rootObjects()[trace::Trace];
	assert fatal (traces->size() = 1);
	traces->initializeProperties();
	traces->map trace();
}

helper trace::Trace::initializeProperties() {
	TARGET_TRANSFORMATION_NAME := "EAtoUML";
	TARGET_TRANSFORMATION := eaToUMLTransformation.rootObjects()[qvtoperational::expressions::OperationalTransformation]->any(true);
}

mapping trace::Trace::trace() : trace::Trace
{
	traceRecords += self.traceRecords->map traceRecord()->flatten();
}

mapping trace::TraceRecord::traceRecord() : List(trace::TraceRecord)
{ 
	result += self.map traceRecordPackage();
	result += self.map traceRecordClassToElement();
	result += self.map traceRecordInterfaceToElement();
	result += self.map traceRecordClassifierToElementBase();
	result += self.map traceRecordClassifierToElement();
	result += self.map traceRecordMapDiagram();
	result += self.map traceRecordMapShape();
}

//TODO create "mapRootPackage" traceRecord from one of the "mapPackage" records.
mapping trace::TraceRecord::traceRecordPackage() : List(trace::TraceRecord)
when {self.mappingOperation.name = "mapPackage"}
{
	var umlDiagram := self.getSelf().modelElement;
	var eaDiagram := self.getResult().modelElement;
	
	result += new TraceRecord("mapPackage", "Package", eaDiagram, "Package", umlDiagram);
}

mapping trace::TraceRecord::traceRecordClassToElement() : List(trace::TraceRecord)
when {self.mappingOperation.name = "mapClassToElement"}
{
	var cls := self.getSelf().modelElement;
	var elem := self.getResult().modelElement;
	
	result += new TraceRecord("mapElementToClass", "Element", elem, "Class", cls);
}

mapping trace::TraceRecord::traceRecordInterfaceToElement() : List(trace::TraceRecord)
when {self.mappingOperation.name = "mapInterfaceToElement"} 
{
	var iface := self.getSelf().modelElement;
	var elem := self.getResult().modelElement;
	
	result += new TraceRecord("mapElementToInterface", "Element", elem, "Interface", iface);
}

mapping trace::TraceRecord::traceRecordClassifierToElementBase() : List(trace::TraceRecord)
when {self.mappingOperation.name = "mapClassifierToElementBase"}
{
	var classifier := self.getSelf().modelElement;
	var elem := self.getResult().modelElement;
	
	result += new TraceRecord("mapElementToClassifierBase", "Element", elem, "Classifier", classifier);
}

mapping trace::TraceRecord::traceRecordClassifierToElement() : List(trace::TraceRecord)
when {self.mappingOperation.name = "mapClassifierToElement"}
{
	var classifier := self.getSelf().modelElement;
	var elem := self.getResult().modelElement;

	result += new TraceRecord("mapElementToClassifier", "Element", elem, "Classifier", classifier);
}

mapping trace::TraceRecord::traceRecordMapDiagram() : List(trace::TraceRecord) 
when {self.mappingOperation.name = "mapDiagram"}
{
	var umlDiagram := self.getSelf().modelElement;
	var eaDiagram := self.getResult().modelElement;
	
	result += new TraceRecord("diagramToDiagram", "Diagram", eaDiagram, "Diagram", umlDiagram);
}

mapping trace::TraceRecord::traceRecordMapShape() : List(trace::TraceRecord) 
when {self.mappingOperation.name = "mapShape"}
{
	var shape := self.getSelf().modelElement;
	var layoutConstraint := shape.oclAsType(notation::Shape).layoutConstraint.oclAsType(ecore::EObject);
	
	var diagramObject := self.getResult().modelElement; 
	
	result += new TraceRecord("diagramObjectToShape", "DiagramObject", diagramObject, "Shape", shape);
	result += new TraceRecord("diagramObjectToLayoutConstraint", "DiagramObject", diagramObject, "Bounds", layoutConstraint);
}
